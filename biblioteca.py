# -*- coding: utf-8 -*-
"""Taller_Repaso_Corte2_KarlaDuque_JorgeGarcia_DanielOviedo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tvaALhgxH9CWNa4_TXuLD1NsG7H3DghW
"""

"""
SISTEMA DE GESTIÓN DE BIBLIOTECA

Este sistema permite administrar los recursos de una biblioteca, incluyendo:
- Catálogo de libros (agregar, eliminar, buscar, mostrar)
- Registro de clientes
- Control de préstamos y devoluciones
- Lista de espera para libros prestados

Estructura principal:
- Clases base (Libro, Nodo, Biblioteca, Cliente, Prestamo, Pila, Cola)
- Sistema principal (SistemaBiblioteca) que integra todas las funcionalidades

Autores: Karla Mariana Duque Callejas; Jorge Antonio García Romero; Daniel Oviedo Vergara
Fecha: 08/04/2025
Versión: 9.9
"""
from datetime import datetime
import time

# ================== CLASES BASE ==================
class Libro:
    """Clase que representa un libro en el sistema de biblioteca.

    Atributos:
        id (str): Identificador único del libro
        titulo (str): Título del libro
        autor (str): Autor del libro
        genero (str): Género literario
        año (str): Año de publicación
        prestado (bool): Estado de préstamo (True si está prestado)
    """
    def __init__(self, id, titulo, autor, genero, año):
        self.id = id
        self.titulo = titulo
        self.autor = autor
        self.genero = genero
        self.año = año
        self.prestado = False

    def __str__(self):
        """Representación en string del libro, mostrando su estado."""
        estado = " (Prestado)" if self.prestado else " (Disponible)"
        return f"Código: {self.id}, Título: {self.titulo}, Autor: {self.autor}, Año: {self.año}{estado}"

class Nodo:
    """Nodo para lista enlazada simple que almacena libros."""
    def __init__(self, libro):
        self.libro = libro
        self.next = None

class Biblioteca:
    """Clase optimizada para gestionar la colección de libros."""

    def __init__(self):
        self.libros_por_id = {}      # id: Libro
        self.libros_por_genero = {}  # genero: set de ids
        self.libros_por_autor = {}   # autor: set de ids

    def agregar_libro(self, libro):
        start = time.time()
        if libro.id in self.libros_por_id:
            print("El ID del libro ya existe")
            return False
        self.libros_por_id[libro.id] = libro

        # Indexación por género
        genero = libro.genero.lower()
        if genero not in self.libros_por_genero:
            self.libros_por_genero[genero] = set()
        self.libros_por_genero[genero].add(libro.id)

        # Indexación por autor
        autor = libro.autor.lower()
        if autor not in self.libros_por_autor:
            self.libros_por_autor[autor] = set()
        self.libros_por_autor[autor].add(libro.id)
        end = time.time()
        print(f"Agregar libro tomó {end - start:.8f} segundos")
        return True

    def eliminar_libro(self, id):
        start = time.time()
        libro = self.libros_por_id.get(id)
        if not libro:
            print("Libro no encontrado")
            return
        if libro.prestado:
            print("No se puede eliminar, el libro está prestado")
            return
        # Remover de índices
        self.libros_por_genero[libro.genero.lower()].discard(id)
        self.libros_por_autor[libro.autor.lower()].discard(id)
        del self.libros_por_id[id]
        end = time.time()
        print(f"Eliminar libro tomó {end - start:.8f} segundos")
        print("Libro eliminado correctamente")

    def buscar_libro_id(self, id):
        start = time.time()
        resultado = self.libros_por_id.get(id)
        end = time.time()
        print(f"Buscar libro por ID tomó {end - start:.8f} segundos")
        return resultado

    def buscar_libro_genero(self, genero):
        start = time.time()
        ids = self.libros_por_genero.get(genero.lower(), set())
        resultado = [self.libros_por_id[i] for i in ids]
        end = time.time()
        print(f"Buscar libros por género tomó {end - start:.8f} segundos")
        return resultado

    def buscar_libro_autor(self, autor):
        start = time.time()
        ids = self.libros_por_autor.get(autor.lower(), set())
        resultado = [self.libros_por_id[i] for i in ids]
        end = time.time()
        print(f"Buscar libros por autor tomó {end - start:.8f} segundos")
        return resultado

    def mostrar_biblioteca(self, orden=None):
        start = time.time()
        libros = list(self.libros_por_id.values())
        if not libros:
            print("La biblioteca está vacía")
            return
        if orden == "titulo":
            libros.sort(key=lambda x: x.titulo.lower())
        elif orden == "año":
            libros.sort(key=lambda x: x.año)
        for libro in libros:
            print(libro)
        end = time.time()
        print(f"Mostrar biblioteca tomó {end - start:.8f} segundos")

    def marcar_como_prestado(self, id_libro):
        start = time.time()
        libro = self.libros_por_id.get(id_libro)
        if libro and not libro.prestado:
            libro.prestado = True
            end = time.time()
            print(f"Marcar como prestado tomó {end - start:.8f} segundos")
            return True
        end = time.time()
        print(f"Marcar como prestado tomó {end - start:.8f} segundos")
        return False

    def marcar_como_devuelto(self, id_libro):
        start = time.time()
        libro = self.libros_por_id.get(id_libro)
        if libro and libro.prestado:
            libro.prestado = False
            end = time.time()
            print(f"Marcar como devuelto tomó {end - start:.8f} segundos")
            return True
        end = time.time()
        print(f"Marcar como devuelto tomó {end - start:.8f} segundos")
        return False
    
class Cliente:
    """Clase que representa un cliente de la biblioteca.

    Atributos:
        id (str): Identificador único del cliente
        nombre (str): Nombre completo
        telefono (str): Número de teléfono
    """
    def __init__(self, id, nombre, telefono):
        self.id = id
        self.nombre = nombre
        self.telefono = telefono

    def __str__(self):
        """Representación en string del cliente."""
        return f"ID: {self.id}, Nombre: {self.nombre}, Teléfono: {self.telefono}"

class Prestamo:
    """Clase que registra los préstamos de libros a clientes.

    Atributos:
        id (str): Identificador único del préstamo
        cliente (Cliente): Cliente que realizó el préstamo
        libro (Libro): Libro prestado
        fecha_prestamo (str): Fecha de préstamo (DD/MM/AAAA)
        fecha_devolucion (str): Fecha de devolución (opcional)
    """
    def __init__(self, id, cliente, libro, fecha_prestamo, fecha_devolucion=None):
        self.id = id
        self.cliente = cliente
        self.libro = libro
        self.fecha_prestamo = fecha_prestamo
        self.fecha_devolucion = fecha_devolucion

    def __str__(self):
        """Representación en string del préstamo."""
        devolucion = f", Fecha devolución: {self.fecha_devolucion}" if self.fecha_devolucion else ""
        return f"Préstamo ID: {self.id}, Cliente: {self.cliente.nombre}, Libro: {self.libro.titulo}, Fecha préstamo: {self.fecha_prestamo}{devolucion}"

class Pila:
    """Implementación de estructura LIFO (último en entrar, primero en salir).

    Usada para gestionar el historial de devoluciones.
    """
    def __init__(self):
        self.pila = []

    def is_empty(self):
        """Verifica si la pila está vacía."""
        return len(self.pila) == 0

    def push(self, dato):
        """Agrega un elemento a la pila."""
        self.pila.append(dato)

    def pop(self):
        """Elimina y devuelve el elemento en el tope de la pila."""
        if self.is_empty():
            raise IndexError("La pila está vacía")
        return self.pila.pop()

    def peek(self):
        """Muestra el elemento en el tope sin eliminarlo."""
        if self.is_empty():
            raise IndexError("La pila está vacía")
        return self.pila[-1]

    def size(self):
        """Devuelve el número de elementos en la pila."""
        return len(self.pila)

class Cola:
    """Implementación de estructura FIFO (primero en entrar, primero en salir).

    Usada para gestionar la lista de espera de clientes.
    """
    def __init__(self):
        self.cola = []

    def is_empty(self):
        """Verifica si la cola está vacía."""
        return len(self.cola) == 0

    def enqueue(self, dato):
        """Agrega un elemento al final de la cola."""
        self.cola.append(dato)

    def dequeue(self):
        """Elimina y devuelve el primer elemento de la cola."""
        if self.is_empty():
            raise IndexError("La cola está vacía")
        return self.cola.pop(0)

    def size(self):
        """Devuelve el número de elementos en la cola."""
        return len(self.cola)

    def peek(self):
        """Muestra el primer elemento sin eliminarlo."""
        if self.is_empty():
            raise IndexError("La cola está vacía")
        return self.cola[0]

# ================== SISTEMA PRINCIPAL ==================
class SistemaBiblioteca:
    """Clase principal que integra todas las funcionalidades del sistema.

    Atributos:
        biblioteca (Biblioteca): Gestión de libros
        clientes (list): Lista de clientes registrados
        prestamos (list): Lista de préstamos activos
        pila_devoluciones (Pila): Historial de devoluciones
        cola_espera (Cola): Lista de espera para préstamos
    """
    def __init__(self):
        self.biblioteca = Biblioteca()
        self.clientes = []
        self.prestamos = []
        self.pila_devoluciones = Pila()
        self.cola_espera = Cola()

    # ========== MÉTODOS DE VALIDACIÓN ==========
    def _es_id_libro_unico(self, id):
        """Verifica si un ID de libro es único."""
        actual = self.biblioteca.head
        while actual is not None:
            if actual.libro.id == id:
                return False
            actual = actual.next
        return True

    def _es_id_cliente_unico(self, id):
        """Verifica si un ID de cliente es único."""
        for cliente in self.clientes:
            if cliente.id == id:
                return False
        return True

    def _es_id_prestamo_unico(self, id):
        """Verifica si un ID de préstamo es único."""
        for prestamo in self.prestamos:
            if prestamo.id == id:
                return False
        return True

    def _validar_fecha(self, fecha_str):
        """Valida que una fecha tenga formato DD/MM/AAAA."""
        try:
            datetime.strptime(fecha_str, "%d/%m/%Y")
            return True
        except ValueError:
            return False

    # ========== MENÚ PRINCIPAL ==========
    def menu_principal(self):
        """Muestra el menú principal y gestiona las opciones."""
        while True:
            print("\n" + "="*50)
            print("SISTEMA DE GESTIÓN DE BIBLIOTECA")
            print("="*50)
            print("1. Gestión de Libros")
            print("2. Gestión de Clientes")
            print("3. Gestión de Préstamos")
            print("4. Devoluciones")
            print("5. Lista de Espera")
            print("6. Salir")

            opcion = input("Seleccione una opción: ")

            if opcion == "1":
                self.menu_libros()
            elif opcion == "2":
                self.menu_clientes()
            elif opcion == "3":
                self.menu_prestamos()
            elif opcion == "4":
                self.menu_devoluciones()
            elif opcion == "5":
                self.menu_lista_espera()
            elif opcion == "6":
                print("\n¡Gracias por usar el sistema!")
                break
            else:
                print("Opción no válida. Intente nuevamente.")

    # ========== GESTIÓN DE LIBROS ==========
    def menu_libros(self):
        """Muestra el menú de gestión de libros."""
        while True:
            print("\n" + "-"*50)
            print("GESTIÓN DE LIBROS")
            print("-"*50)
            print("1. Agregar libro")
            print("2. Eliminar libro")
            print("3. Buscar libro por ID")
            print("4. Buscar libros por género")
            print("5. Mostrar todos los libros")
            print("6. Mostrar libros ordenados")
            print("7. Volver al menú principal")

            opcion = input("Seleccione una opción: ")

            if opcion == "1":
                self.agregar_libro()
            elif opcion == "2":
                self.eliminar_libro()
            elif opcion == "3":
                self.buscar_libro_id()
            elif opcion == "4":
                self.buscar_libros_genero()
            elif opcion == "5":
                self.mostrar_libros()
            elif opcion == "6":
                self.mostrar_libros_ordenados()
            elif opcion == "7":
                break
            else:
                print("Opción no válida. Intente nuevamente.")

    def agregar_libro(self):
        """Interfaz para agregar un nuevo libro a la biblioteca."""
        print("\n" + "="*50)
        print("AGREGAR NUEVO LIBRO")
        print("="*50)

        # Validación de ID único
        while True:
            id = input("ID del libro: ").strip()
            if not id:
                print("El ID no puede estar vacío")
                continue
            if not id.isdigit():
                print("El Id debe ser un número")
                continue
            if not self._es_id_libro_unico(id):
                print("Este ID de libro ya existe")
                continue
            break

        # Validación de título obligatorio
        titulo = input("Título: ").strip()
        while not titulo:
            print("El título no puede estar vacío")
            titulo = input("Título: ").strip()

        # Otros campos
        autor = input("Autor: ").strip()
        genero = input("Género: ").strip()

        # Validación de año numérico
        while True:
            año = input("Año de publicación: ").strip()
            if año.isdigit():
                break
            print("El año debe ser un número")

        nuevo_libro = Libro(id, titulo, autor, genero, año)
        if self.biblioteca.agregar_libro(nuevo_libro):
            print("Libro agregado exitosamente.")

    def eliminar_libro(self):
        """Interfaz para eliminar un libro de la biblioteca."""
        print("\n" + "="*50)
        print("ELIMINAR LIBRO")
        print("="*50)
        id = input("Ingrese el ID del libro a eliminar: ").strip()
        self.biblioteca.eliminar_libro(id)

    def buscar_libro_id(self):
        """Interfaz para buscar un libro por su ID."""
        print("\n" + "="*50)
        print("BUSCAR LIBRO POR ID")
        print("="*50)
        id = input("Ingrese el ID del libro: ").strip()
        libro = self.biblioteca.buscar_libro_id(id)
        if libro:
            print("\nLibro encontrado:")
            print(libro)
        else:
            print("Libro no encontrado")

    def buscar_libros_genero(self):
        """Interfaz para buscar libros por género."""
        print("\n" + "="*50)
        print("BUSCAR LIBROS POR GÉNERO")
        print("="*50)
        genero = input("Ingrese el género a buscar: ").strip()
        libros = self.biblioteca.buscar_libro_genero(genero)
        if libros:
            print(f"\nLibros encontrados en el género '{genero}':")
            for libro in libros:
                print(libro)
        else:
            print(f"No se encontraron libros en el género '{genero}'")

    def mostrar_libros(self):
        """Muestra todos los libros en la biblioteca."""
        print("\n" + "="*50)
        print("TODOS LOS LIBROS")
        print("="*50)
        self.biblioteca.mostrar_biblioteca()

    def mostrar_libros_ordenados(self):
        """Muestra libros ordenados por título o año."""
        print("\n" + "="*50)
        print("LIBROS ORDENADOS")
        print("="*50)
        print("1. Ordenar por título")
        print("2. Ordenar por año de publicación")
        print("3. Volver")

        opcion = input("Seleccione una opción: ")

        if opcion == "1":
            print("\nLibros ordenados por título:")
            self.biblioteca.mostrar_biblioteca(orden="titulo")
        elif opcion == "2":
            print("\nLibros ordenados por año:")
            self.biblioteca.mostrar_biblioteca(orden="año")
        elif opcion == "3":
            return
        else:
            print("Opción no válida")

    # ========== GESTIÓN DE CLIENTES ==========
    def menu_clientes(self):
        """Muestra el menú de gestión de clientes."""
        while True:
            print("\n" + "-"*50)
            print("GESTIÓN DE CLIENTES")
            print("-"*50)
            print("1. Registrar nuevo cliente")
            print("2. Mostrar todos los clientes")
            print("3. Buscar cliente por ID")
            print("4. Volver al menú principal")

            opcion = input("Seleccione una opción: ")

            if opcion == "1":
                self.registrar_cliente()
            elif opcion == "2":
                self.mostrar_clientes()
            elif opcion == "3":
                self.buscar_cliente()
            elif opcion == "4":
                break
            else:
                print("Opción no válida. Intente nuevamente.")

    def registrar_cliente(self):
        """Interfaz para registrar un nuevo cliente."""
        print("\n" + "="*50)
        print("REGISTRAR NUEVO CLIENTE")
        print("="*50)

        # Validación de ID único
        while True:
            id = input("ID del cliente: ").strip()
            if not id:
                print("El ID no puede estar vacío")
                continue
            if not id.isdigit():
                print("El ID debe ser un número")
                continue
            if not self._es_id_cliente_unico(id):
                print("Este ID de cliente ya existe")
                continue
            break

        # Validación de nombre obligatorio
        nombre = input("Nombre completo: ").strip()
        while not nombre:
            print("El nombre no puede estar vacío")
            nombre = input("Nombre completo: ").strip()

        telefono = input("Teléfono: ").strip()

        nuevo_cliente = Cliente(id, nombre, telefono)
        self.clientes.append(nuevo_cliente)
        print("Cliente registrado exitosamente.")

    def mostrar_clientes(self):
        """Muestra todos los clientes registrados."""
        print("\n" + "="*50)
        print("LISTA DE CLIENTES")
        print("="*50)
        if not self.clientes:
            print("No hay clientes registrados")
            return

        for cliente in self.clientes:
            print(cliente)

    def buscar_cliente(self):
        """Interfaz para buscar un cliente por ID."""
        print("\n" + "="*50)
        print("BUSCAR CLIENTE")
        print("="*50)
        id = input("Ingrese el ID del cliente: ").strip()

        for cliente in self.clientes:
            if cliente.id == id:
                print("\nCliente encontrado:")
                print(cliente)
                return

        print("No se encontró ningún cliente con ese ID")

    # ========== GESTIÓN DE PRÉSTAMOS ==========
    def menu_prestamos(self):
        """Muestra el menú de gestión de préstamos."""
        while True:
            print("\n" + "-"*50)
            print("GESTIÓN DE PRÉSTAMOS")
            print("-"*50)
            print("1. Registrar nuevo préstamo")
            print("2. Mostrar todos los préstamos")
            print("3. Buscar préstamo por ID")
            print("4. Volver al menú principal")

            opcion = input("Seleccione una opción: ")

            if opcion == "1":
                self.registrar_prestamo()
            elif opcion == "2":
                self.mostrar_prestamos()
            elif opcion == "3":
                self.buscar_prestamo()
            elif opcion == "4":
                break
            else:
                print("Opción no válida. Intente nuevamente.")

    def registrar_prestamo(self):
        """Interfaz para registrar un nuevo préstamo."""
        print("\n" + "="*50)
        print("REGISTRAR NUEVO PRÉSTAMO")
        print("="*50)

        if not self.clientes:
            print("No hay clientes registrados. Registre un cliente primero.")
            return

        # Validación ID préstamo único
        while True:
            id_prestamo = input("\nID del préstamo: ").strip()
            if not id_prestamo:
                print("El ID no puede estar vacío")
                continue
            if not self._es_id_prestamo_unico(id_prestamo):
                print("Este ID de préstamo ya existe")
                continue
            break

        # Selección de cliente
        print("\nClientes disponibles:")
        for i, cliente in enumerate(self.clientes, 1):
            print(f"{i}. {cliente.nombre} (ID: {cliente.id})")

        try:
            cliente_idx = int(input("\nSeleccione el número del cliente: ")) - 1
            cliente_seleccionado = self.clientes[cliente_idx]
        except (ValueError, IndexError):
            print("Selección no válida")
            return

        # Mostrar solo libros disponibles
        print("\nLibros disponibles:")
        actual = self.biblioteca.head
        libros_disponibles = []
        while actual is not None:
            if not actual.libro.prestado:
                libros_disponibles.append(actual.libro)
            actual = actual.next

        if not libros_disponibles:
            print("No hay libros disponibles para préstamo")
            return

        for i, libro in enumerate(libros_disponibles, 1):
            print(f"{i}. {libro.titulo} (ID: {libro.id})")

        try:
            libro_idx = int(input("\nSeleccione el número del libro: ")) - 1
            libro_seleccionado = libros_disponibles[libro_idx]
        except (ValueError, IndexError):
            print("Selección no válida")
            return

        # Validación de fecha
        while True:
            fecha_prestamo = input("Fecha de préstamo (DD/MM/AAAA): ").strip()
            if self._validar_fecha(fecha_prestamo):
                break
            print("Formato de fecha incorrecto. Use DD/MM/AAAA")

        # Registrar préstamo
        if not self.biblioteca.marcar_como_prestado(libro_seleccionado.id):
            print("Error al registrar el préstamo")
            return

        nuevo_prestamo = Prestamo(
            id=id_prestamo,
            cliente=cliente_seleccionado,
            libro=libro_seleccionado,
            fecha_prestamo=fecha_prestamo
        )

        self.prestamos.append(nuevo_prestamo)
        print("\nPréstamo registrado exitosamente:")
        print(nuevo_prestamo)

    def mostrar_prestamos(self):
        """Muestra todos los préstamos registrados."""
        print("\n" + "="*50)
        print("LISTA DE PRÉSTAMOS")
        print("="*50)
        if not self.prestamos:
            print("No hay préstamos registrados")
            return

        for prestamo in self.prestamos:
            print(prestamo)
            print("-"*50)

    def buscar_prestamo(self):
        """Interfaz para buscar un préstamo por ID."""
        print("\n" + "="*50)
        print("BUSCAR PRÉSTAMO")
        print("="*50)
        id_prestamo = input("Ingrese el ID del préstamo: ").strip()

        for prestamo in self.prestamos:
            if prestamo.id == id_prestamo:
                print("\nPréstamo encontrado:")
                print(prestamo)
                return

        print("No se encontró ningún préstamo con ese ID")

    # ========== GESTIÓN DE DEVOLUCIONES ==========
    def menu_devoluciones(self):
        """Muestra el menú de gestión de devoluciones."""
        while True:
            print("\n" + "-"*50)
            print("GESTIÓN DE DEVOLUCIONES")
            print("-"*50)
            print("1. Registrar devolución")
            print("2. Mostrar última devolución")
            print("3. Mostrar todas las devoluciones")
            print("4. Volver al menú principal")

            opcion = input("Seleccione una opción: ")

            if opcion == "1":
                self.registrar_devolucion()
            elif opcion == "2":
                self.mostrar_ultima_devolucion()
            elif opcion == "3":
                self.mostrar_todas_devoluciones()
            elif opcion == "4":
                break
            else:
                print("Opción no válida. Intente nuevamente.")

    def registrar_devolucion(self):
        """Interfaz para registrar la devolución de un libro."""
        print("\n" + "="*50)
        print("REGISTRAR DEVOLUCIÓN")
        print("="*50)
        id_prestamo = input("Ingrese el ID del préstamo: ").strip()

        # Buscar préstamo activo
        prestamo_encontrado = None
        for prestamo in self.prestamos:
            if prestamo.id == id_prestamo and prestamo.fecha_devolucion is None:
                prestamo_encontrado = prestamo
                break

        if prestamo_encontrado is None:
            print("No se encontró un préstamo activo con ese ID")
            return

        # Validación de fecha
        while True:
            fecha_devolucion = input("Ingrese la fecha de devolución (DD/MM/AAAA): ").strip()
            if self._validar_fecha(fecha_devolucion):
                break
            print("Formato de fecha incorrecto. Use DD/MM/AAAA")

        # Actualizar préstamo
        prestamo_encontrado.fecha_devolucion = fecha_devolucion

        # Marcar libro como disponible
        if not self.biblioteca.marcar_como_devuelto(prestamo_encontrado.libro.id):
            print("Error al registrar la devolución")
            return

        # Agregar a pila de devoluciones
        self.pila_devoluciones.push(prestamo_encontrado.libro)
        print("\nDevolución registrada exitosamente:")
        print(f"Libro: {prestamo_encontrado.libro.titulo}")
        print(f"Cliente: {prestamo_encontrado.cliente.nombre}")
        print(f"Fecha devolución: {fecha_devolucion}")

    def mostrar_ultima_devolucion(self):
        """Muestra la última devolución registrada."""
        print("\n" + "="*50)
        print("ÚLTIMA DEVOLUCIÓN REGISTRADA")
        print("="*50)
        if self.pila_devoluciones.is_empty():
            print("No hay devoluciones registradas")
            return

        libro_devuelto = self.pila_devoluciones.peek()
        print("Último libro devuelto:")
        print(libro_devuelto)

    def mostrar_todas_devoluciones(self):
        """Muestra el historial completo de devoluciones."""
        print("\n" + "="*50)
        print("HISTORIAL DE DEVOLUCIONES")
        print("="*50)
        if self.pila_devoluciones.is_empty():
            print("No hay devoluciones registradas")
            return

        # Copia temporal para no perder datos
        temp_pila = Pila()
        contador = 1

        print("\nDevoluciones (más reciente primero):")
        while not self.pila_devoluciones.is_empty():
            libro = self.pila_devoluciones.pop()
            temp_pila.push(libro)
            print(f"{contador}. {libro.titulo} (ID: {libro.id})")
            contador += 1

        # Restaurar la pila original
        while not temp_pila.is_empty():
            self.pila_devoluciones.push(temp_pila.pop())

    # ========== GESTIÓN DE LISTA DE ESPERA ==========
    def menu_lista_espera(self):
        """Muestra el menú de gestión de lista de espera."""
        while True:
            print("\n" + "-"*50)
            print("GESTIÓN DE LISTA DE ESPERA")
            print("-"*50)
            print("1. Agregar cliente a la lista de espera")
            print("2. Atender siguiente cliente")
            print("3. Mostrar lista de espera")
            print("4. Volver al menú principal")

            opcion = input("Seleccione una opción: ")

            if opcion == "1":
                self.agregar_lista_espera()
            elif opcion == "2":
                self.atender_cliente_espera()
            elif opcion == "3":
                self.mostrar_lista_espera()
            elif opcion == "4":
                break
            else:
                print("Opción no válida. Intente nuevamente.")

    def agregar_lista_espera(self):
        """Interfaz para agregar cliente a la lista de espera."""
        print("\n" + "="*50)
        print("AGREGAR A LISTA DE ESPERA")
        print("="*50)
        if not self.clientes:
            print("No hay clientes registrados. Registre un cliente primero.")
            return

        # Mostrar clientes disponibles
        print("\nClientes disponibles:")
        for i, cliente in enumerate(self.clientes, 1):
            print(f"{i}. {cliente.nombre} (ID: {cliente.id})")

        try:
            cliente_idx = int(input("\nSeleccione el número del cliente: ")) - 1
            cliente_seleccionado = self.clientes[cliente_idx]
        except (ValueError, IndexError):
            print("Selección no válida")
            return

        # Agregar a cola de espera
        self.cola_espera.enqueue(cliente_seleccionado)
        print(f"\nCliente {cliente_seleccionado.nombre} agregado a la lista de espera")

    def atender_cliente_espera(self):
        """Interfaz para atender al siguiente cliente en espera."""
        print("\n" + "="*50)
        print("ATENDER CLIENTE EN ESPERA")
        print("="*50)
        if self.cola_espera.is_empty():
            print("No hay clientes en la lista de espera")
            return

        cliente_atendido = self.cola_espera.dequeue()
        print(f"Cliente atendido: {cliente_atendido.nombre} (ID: {cliente_atendido.id})")

    def mostrar_lista_espera(self):
        """Muestra la lista actual de clientes en espera."""
        print("\n" + "="*50)
        print("LISTA DE ESPERA ACTUAL")
        print("="*50)
        if self.cola_espera.is_empty():
            print("No hay clientes en la lista de espera")
            return

        # Copia temporal para no perder datos
        temp_cola = Cola()
        contador = 1

        print("\nOrden de atención:")
        while not self.cola_espera.is_empty():
            cliente = self.cola_espera.dequeue()
            temp_cola.enqueue(cliente)
            print(f"{contador}. {cliente.nombre} (ID: {cliente.id})")
            contador += 1

        # Restaurar la cola original
        while not temp_cola.is_empty():
            self.cola_espera.enqueue(temp_cola.dequeue())

# ================== EJECUCIÓN ==================
if __name__ == "__main__":
    """Punto de entrada principal del programa."""
    sistema = SistemaBiblioteca()
    sistema.menu_principal()